Outline for a book about xv6. Really notes.

questions
  intro chapter about C?
    pointer arithmetic
  each chapter is an intro + walk through some set of code paths
  some way to incorporate the stack &c dumps from the lectures?
    e.g. printing trapframes, single-stepping into user space
    particularly interesting for first process, syscalls, swtch, intr
  some way to keep book line #s synced w/ code?
  maybe put line/sheet #s in the margin?
  exercises?
  hints about looking for stuff in kernel.asm?
  hints on building / modifying / running xv6?
  elf format?
  mkfs
  do the lectures ever explain how fork() works? exec()?
  how it is that fork returns zero in the child
  what do we mean by e.g. "when the process is running"?
    user? kernel? either?
  note only two transitions: user/kernel, kernel/kernel
  the general idea that you usually "resume" and restore "saved" state
  unix.txt examples often don't check error returns; at least mention this.
  general allocation strategy
    proc, bufs, FDs, pipes, user memory
    no general-purpose allocator
    usually fixed-size tables
    why?
    any special plan for locking vs deallocation?

* introduction
  what we are trying to achieve
  how to use the book
  history / motivation

* explanation of what "V6-like UNIX" means
  so non-UNIX people will understand what we're building
  user and kernel, protection
  main abstractions
    processes, memory, file descriptors, pipes
  system calls
    fork, wait, exit
  example: simple shell

* x86 overview
  mostly segments
  MMU, cpl, dpl, selector, descriptor, base
  eflags, EIP, ESP, CS, DS, SS

* first process
  up to first user-level instruction
  mostly about struct proc, segments, stacks, kalloc()
  explain user-half, kernel-half, two stacks, two sets of regs
  not SMP
  not much about locking or scheduler or swtch
  (where is fork())?

* system calls, traps, device interrupts
  talk about protection, CPL

* multiprocessors and locking

* process switching

* sleep/wakeup

* exit / wait / kill

* file descriptors

* pipes

* block I/O
  struct buf
  block cache
  B_BUSY

* file read/write
  inodes, iget, iput
  I_BUSY

* directory operations
  lookup, create, unlink

* file system crash recovery (?)

* odds and ends
  appendix, or put somewhere else, or drop
  SMP boot
  console driver
  IDE disk driver
