This chapter describes the interface for which xv6 is the
implementation.

xv6 takes the form of a "kernel": a special program that provides
services to running programs. Each running program, called a
"process", has memory containing instructions, data, and a stack. When
a process needs to invoke a kernel service, it makes a "system call"
to enter the kernel; the kernel performs the service and returns. Thus
a process alternates between executing in "user space" and in "kernel
space".

The kernel uses the CPU's hardware protection mechanisms to ensure
that each process executing in user space can only access its own
memory. The kernel executes with the hardware privileges required to
implement these protections, while user-space code executes without
privilege. Invocation of a system call both raises the hardware
privilege level and jumps into the kernel.

The xv6 kernel provides a subset of the services and system calls that
UNIX kernels traditionally offer.  The following paragraphs outline
xv6's services, which include processes, memory, file descriptors,
pipes, and a file system.

* Processes and Memory

An xv6 process consists of user-space memory (instructions, data, and
stack) along with some state inside the kernel.  xv6 provides
time-sharing: it transparently switches the available CPUs among the
set of process which wish to execute. When a process is not executing,
xv6 saves its CPU registers, restoring them when it next runs the
process. Each process has a unique numeric non-zero process ID (pid).

One process may create another with the fork() system call. fork()
creates a new process with exactly the same memory contents as the
process that called fork; the former is called the "child" and the
latter the "parent".  The child starts executing with a return from
fork(). The main difference between the parent and child is that the
parent's fork() returns the child's process ID, while the child's
fork() returns zero. Here's an example:

  int pid;

  pid = fork();
  if(pid == 0){
    printf("I am the child.\n");
    exit();
  } else if(pid > 0){
    printf("I am the parent; child's pid is %d.\n", pid);
    wait();
  } else {
    printf("fork() returned an error.\n");
  }

The exit() system call causes a process to die. The wait() system call
waits for any of a process's children to die, and then returns.  The
kill(pid) system call takes a process ID as an argument, and causes
that process to die.

A process may overwrite itself with a program stored in a file with
the exec() system call.  The file must contain an ELF-format
executable.  If all goes well, exec() does not really return; instead,
the instructions loaded from the file start executing at the
entry-point declared in the ELF header. exec() takes two arguments:
the name of the file containing the executable, and an array
of string arguments. For example:

  char *args[3];
  args[0] = "echo";
  args[1] = "hello";
  args[2] = 0;
  exec("/bin/echo", args);

xv6 allocates most user-space memory implicitly: fork() allocates the
memory required for the child's copy of the parent's memory, and
exec() allocates enough memory to hold the executable file.  A process
that needs more memory at run-time (perhaps in malloc()) can call
sbrk(n) to allocate n bytes of memory. sbrk() returns the address of
the new memory. xv6 places the new memory just after all of the
process's existing memory.

xv6 does not provide a notion of users or protecting one user from
another; all processes essentially run as root.

* File descriptors

A file descriptor represents an I/O destination to which a process may
write bytes or from which it may read. A file descriptor may refer to
a file, a directory, a pipe to another process, or the console. A file
descriptor takes the form of a small integer; the kernel uses it to
index into an internal table.

By convention, file descriptor 0 provides input to a program, and file
descriptor 1 refers to the desired destination of its output (called
standard input and standard output). The UNIX shell exploits this
convention to implement I/O redirection and pipelines.

The read() and write() system calls read and write bytes from/to file
descriptors. This code copies its standard input to its standard
output:

  while(1){
    char buf[512];
    int n = read(0, buf, sizeof(buf));
    if(n <= 0)
      break;
    if(write(1, buf, n) != n){
      printf("write error\n");
      exit();
    }
  }

read(fd, buf, n) waits until data is available on file descriptor fd,
copies up to n bytes of input into buf, and returns that number of
bytes. read() consumes those bytes: a subsequent read() will yield the
bytes that follow in the input stream. If the file descriptor will
never yield any more data, read() returns zero to indicate
end-of-file; this condition arises at the end of an ordinary file, or
when reading from a pipe whose writing end has been closed.

close(fd) indicates that the process no longer needs the file
descriptor. That descriptor is now free in the calling process, and
the kernel may return it from a future open(), pipe(), or dup() (see
below). The kernel always allocates the lowest-numbered free file
descriptor.

fork() gives the child an initial set of file descriptors that are
identical to the parent's descriptors. exec() preserves the calling
process's descriptors. This behavior allows programs such as the shell
to implement I/O redirection by fork()ing, setting up the desired I/O
environment in the child, and then calling exec(). Here is a
simplified version of the code a shell runs when you type
"program<infile".

  char args[] = { "program", "program", 0 };
  if(fork() == 0){
    close(0);
    open("infile", 0);
    exec("program", args);
  }

What happens when a process fork()s and both parent and child read or
write the file descriptors that they now share? For example:

  if(fork() == 0){
    write(1, "x", 1);
  } else {
    write(1, "y", 1);
  }

Both parent and child write to the standard output. Will one write
overwrite the other, yielding a file with just one byte (either x or
y)? No. File descriptors with the same ultimate origin, but copied by
fork() or dup(), share an "offset" in their kernel state indicating
the position of the next byte to be read or written. In the above
code, the first write() increments the shared offset, so that the data
from the second write() appears after that from the first. This
behavior helps produce useful results from shell commands
such as (echo x ; echo y) > outfile.

A nice aspect of file descriptors is that they are equally at home
with random-access and stream I/O. For example, a program that reads
its standard input usually does not need to be aware of whether the
input comes from the console, a file, or a pipe.

pipe section uses dup()...

* Pipes

A pipe appears to processes as a pair of file descriptors, one for
writing and one for reading. A sequence of bytes written to the former
appear when the latter is read. 

The most common use for pipes is for communication between processes.
The following code fork()s a process to run cat and writes "hello" to
it via a pipe:

  int pipe_fds[2];
  char *args[] = { "cat", 0 };
  pipe(pipe_fds);
  if(fork() == 0){
    close(0);
    dup(pipe_fds[0]);
    close(pipe_fds[0]);
    close(pipe_fds[1]);
    exec("/bin/cat", args);
  } else {
    close(pipe_fds[0]);
    write(pipe_fds[1], "hello\n", 6);
    close(pipe_fds[1]);
  }

The program first creates a new pipe with the pipe() system call.
pipe() returns the pipe's two file descriptors in the array passed as
its argument, the read descriptor followed by the write descriptor.
The fork()ed child inherits both file descriptors. The close() and
dup() sequence causes descriptor 0 (the standard input) to refer to
the read side of the pipe. Now the cat command will run with input
from the pipe. After the fork() the parent writes to the pipe's write
descriptor, and closes both descriptors.

A read on a pipe waits for some data to be written. The read may
return less data than requested. If there are no open file descriptors
referring to the pipe's write side, and there is no more data waiting
to be read, a read will return -1 to indicate end-of-file. This is one
reason why it's important that the child in the above code example
closes its copy of the pipe's write descriptor; otherwise it would
never see end-of-file.

You may wonder why UNIX has special kernel support for pipes, when
file redirection can be used to get a similar effect. For example, the
following two shell commands produce the same output:

  echo hello | cat
  echo hello > /tmp/xyz ; cat < /tmp/xyz

If the kernel didn't provide pipes, you could imagine a shell
implementing "|" with file redirection. One reason pipes are
preferable is that they automatically clean themselves up, while with
file redirection the shell would have to be careful to remove
/tmp/xyz. A second reason is that pipes can pass arbitrarily long
streams of data, while file redirection requires enough free space on
the disk to store all the data.

* File System
[SYS_chdir]   sys_chdir,
[SYS_fstat]   sys_fstat,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_mknod]   sys_mknod,
[SYS_open]    sys_open,
[SYS_unlink]  sys_unlink,

unlink vs close
links (ok, mostly the issue is implementation: link cnt vs inode ref cnt)

* Example: A simple shell

Maybe the code examples above are all that's needed;
it's not clear what more a full shell would add.
