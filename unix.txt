* explanation of what "V6-like UNIX" means
  so non-UNIX people will understand what we're building
  user and kernel, protection
  main abstractions
    processes, memory, file descriptors, pipes
  system calls
    fork, wait, exit
  example: simple shell

xv6 takes the form of a "kernel": a special program that provides
services to running programs. Each running program, called a
"process", has instructions, data, and a stack. When a process needs
to invoke a kernel service, it makes a "system call" to enter the
kernel; the kernel performs the service and returns. Thus a process
alternates between executing in "user space" and in "kernel space".

The kernel uses the CPU's hardware protection mechanisms to ensure
that each process executing in user space can only access its own
memory.  The kernel executes with the hardware privileges required to
implement these protections, while user-space process code executes
without privilege.  A system call both raises the hardware privilege
level and jumps to code inside the kernel.

The xv6 kernel provides a subset of the services and system calls that
UNIX kernels traditionally offer.  The following paragraphs outline
xv6's services, which include processes, memory, file descriptors,
pipes, and a file system.

* Processes and Memory

An xv6 process consists of user-space memory (instructions, data, and
stack) along with some state inside the kernel.  xv6 provides
time-sharing: it transparently switches the available CPUs among the
set of process which wish to execute. When a process is not executing,
xv6 saves its CPU registers, restoring them when it next runs the
process. Each process has a unique numeric non-zero process ID (pid).

One process may create another with the fork() system call. fork()
creates a new process with exactly the same memory contents as the
process that called fork; the former is called the "child" and the
latter the "parent".  The child starts executing with a return from
fork(). The main difference between the parent and child is that the
parent's fork() returns the child's process ID, while the child's
fork() returns zero. Here's an example:

  int pid;

  pid = fork();
  if(pid == 0){
    printf("I am the child.\n");
    exit();
  } else if(pid > 0){
    printf("I am the parent; child's pid is %d.\n", pid);
    wait();
  } else {
    printf("fork() returned an error.\n");
  }

The exit() system call causes a process to die. The wait() system call
waits for any of a process's children to die, and then returns.  The
kill(pid) system call takes a process ID as an argument, and causes
that process to die.

A process may overwrite itself with a program stored in a file with
the exec() system call.  The file must contain an ELF-format
executable.  If all goes well, exec() does not really return; instead,
the instructions loaded from the file start executing at the
entry-point declared in the ELF header. exec() takes two arguments:
the name of the file containing the executable, and an array
of string arguments. For example:

  char *args[3];
  args[0] = "echo";
  args[1] = "hello";
  args[2] = 0;
  exec("/bin/echo", args);

xv6 allocates most user-space memory implicity: fork() allocates the
memory required for the child's copy of the parent's memory, and
exec() allocates enough memory to hold the executable file.  A process
that needs more memory at run-time (perhaps in malloc()) can call
sbrk(n) to allocate n bytes of memory. sbrk() returns the address of
the new memory. xv6 places the new memory just after all of the
process's existing memory.

* File descriptors
[SYS_read]    sys_read,
[SYS_write]   sys_write,
[SYS_close]   sys_close,
[SYS_dup]     sys_dup,

Inherited across fork.
seek offset (though no seek).
stdin, stdout.
eof (zero read).
read and write may block

* Pipes
[SYS_pipe]    sys_pipe,
example of typical use w/ fork
finite buffer
last close (ref cnt)
close on one end vs close on both ends
eof
blocking write
blocking read

* File System
[SYS_chdir]   sys_chdir,
[SYS_fstat]   sys_fstat,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_mknod]   sys_mknod,
[SYS_open]    sys_open,
[SYS_unlink]  sys_unlink,

unlink vs close
links (ok, mostly the issue is implementation: link cnt vs inode ref cnt)

* Example: A simple shell
Or maybe fire up a program with output redirected.
