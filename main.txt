This chapter will trace through xv6's initialization code, focusing on
the creation of the first process. It will end with the execution of
the first user-space instruction (which will turn out to be at line
6708). Along the way you'll learn about the structure of an xv6
process, about xv6's memory management, and about kernel->user
transitions.

When you first turn on a PC, it executes some hardware setup code
stored in non-volatile memory. This code is supplied by the PC's
manufacturer, and is usually called the BIOS. The last thing the BIOS
does is load the first sector (512 bytes) from the hard drive into
memory at 0x7c00, and then jump to 0x7c00. That sector is called the
boot block.

xv6 provides its own boot block, whose code is in bootasm.S and
bootmain.c.  bootasm.S sets up the CPU's memory management unit to map
32-bit virtual addresses directly to physical memory.  Specifically:
line 0957 turns on protected mode, line 0961 enters 32-bit mode, and
the segment descriptors loaded at line 0954 cause virtual addresses to
be used as physical addresses. Line 0974 puts the top of the stack at
0x7c00; it grows down from there.

bootmain.c loads the xv6 kernel from hard drive 0 into memory.  It
expects the kernel to start at sector 1 (the second sector) and to be
in ELF format. The Makefile initializes the disk 0 image so that this
is true; see the xv6.img target. The ELF format indicates the address
at which the executable file expects to be loaded into memory and its
entry address; bootmain.c obeys these directions.  Makefile links the
kernel so that it will be loaded into memory starting at address
0x100000, and so that its entry address is main(); see the kernel
target in the Makefile. The reason for loading the kernel at 0x100000
rather than 0x0 is to avoid conflicts with resources the PC hardware
stores in the first megabyte of memory (trap vectors, the VGA frame
buffer, the executing boot block at 0x7c00, etc.).

xv6 proper starts in main() on sheet 12. For now we are only
interested in line 1235, which calls userinit() to create the first
process.  userinit() is on sheet 17.

Each process in xv6 has three main parts: a proc structure, some user
memory, and a kernel stack.  A proc structure (sheet 15) is an entry
in the proc[] array; it holds pointers to the memory and kernel stack,
as well as other data such as saved registers.  xv6 often uses the
variable p to refer to a proc structure.

A process's user memory (p->mem) holds the process's instructions,
data, and stack.  p->sz holds the size of the process's user memory.
When the process is running user instructions, xv6 instructs the MMU
to map virtual address zero to be the start of user memory, so that
each user process has the illusion of having a dedicated memory
system. The user instructions start at p->mem; the user stack is at
the end (p->mem + p->sz) and grows down.

When a process is executing in the kernel, for example in a system
call, it must have a stack on which to save variables and function
call return addresses.  xv6 allocates one stack for each process for
use when it is in the kernel, called the process's kernel stack
(p->kstack).  This is a separate stack from the user stack, since the
user stack may not be valid.  Each process has its own kernel stack
(rather than all sharing a single stack) so that a system call may
wait (or "block") in the kernel to wait for I/O, and resume where it
left off when the I/O has finished; the process's kernel stack saves
much of the state required for such a resumption.

Ordinarily processes are only created by fork(), so a new process
starts life copied from its parent.  The result of fork() is a child
that has identical user memory contents to its parent.  The child
starts life running in the kernel, with a specially prepared kernel
stack and set of kernel registers that cause it to "return" to user
space at the same place (the return from fork()) as the parent.  That
return sequence loads values into the registers that were previously
saved when the parent process called fork().

userinit() operates by mimicing fork() as much as it can. The main
difference is that it provides its own user memory and "saved" user
registers.

userinit() calls copyproc() (also sheet 17) to allocate and partially
initialize the first process. copyproc()'s usual job is to copy an
existing process, indicated by its argument, as part of the fork()
system call.  For this call the null argument indicates that there is
nothing to copy. The call to allocproc() (sheet 16) finds an unused
slot in the procs[] array and marks it as in-use. Copyproc then
allocates a kernel stack and reserves space at the top of the stack
for "saved" user registers, in a struct trapframe (sheet 04).  This is
where a call to fork() would ordinarily save user registers.  Finally,
copyproc() sets the values of the registers the process will have when
it first executes in the kernel. For reasons to be explained in a
later chapter, these values live on the process's kernel stack, at a
point indicated by the process's p->context. copyproc() sets up this
arrangement, and sets the process's EIP so that it will start
executing in forkret() (sheet 18).

When copyproc() is done, userinit() allocates memory for the first
process, sets its current working directory (in p->cwd), zeros the
"saved" user registers (line 1766), and then sets up the saved
registers so that the process will execute correctly.  These saved
registers will be loaded into the CPU hardware when the new process
eventually enters user space.  Lines 1767 through 1770 set the segment
selectors that the user process will use to refer to different segment
descriptors than those used by the kernel; later on the kernel will
cause those segment descriptors to refer to p->mem, so that the
process will only be able to use its own memory. Line 1771 ensures
that interrupts will be enabled when running user code. Line 1772 sets
the user stack pointer to refer to the end of user memory, and 1779
sets the initial program counter to zero.  userinit() copies
instructions and data generated from initcode.S (sheet 67) into the
new process's user memory. copyproc() marks the new process ready to
run and returns.

We're now back to main on sheet 12; the next interesting action is the
call to scheduler() (sheet 18).  scheduler() looks for a runnable
process, sets up appropriate user segments with setupsegs(), and then
switches to the process's stack and EIP with swtch().

At any given time in xv6 there are two sets of segment descriptors
loaded into the CPU's global descriptor table.  One set allows the
kernel to refer to all of physical memory (these two descriptors are
SEG_KCODE and SEG_KDATA). The other set allows user code to refer only
to the current process's user memory (these two descriptors are
SEG_UCODE and SEG_UDATA).  When xv6 starts running a process, it must
set the user segment descripts correctly. That is the job of
setupsegs().

setupsegs() (sheet 16) creates the user segment descriptors on lines
1690 and 1691.  Both descriptors have base set to p->mem, so that user
address zero will refer to physical address p->mem. Both descriptors
have their limit set to p->sz, so that user code will not be able to
refer addresses beyond the range of allocated memory. Both descriptors
have a descriptor privilege level (DPL) of DPL_USER, or 3, so that user code
can access the segments.

setupsegs() initializes the kernel descriptors with a DPL of zero,
which means user code cannot use these descriptors.  setupsegs()
initializes the TSS, whose only function in xv6 is to tell the CPU
what stack to use when an interrupts occurs while running user code
(line 1680 causes interrupts to use the current process's kernel
stack). Finally, line 1700 tells the CPU to use the new descriptors.
Of course, the currently executing code uses the kernel descriptors,
which haven't changed, but the new user descriptors will be used
shortly.

Remember that scheduler() next calls swtch() (sheet 21).  swtch()
basically loads the saved kernel registers from the p->context of the
target process (a future chapter will discuss swtch() more fully).  In
this case the saved registers are the ones that copyproc() put into
the first process's p->context. The only registers that really are EIP
and ESP, which now point to forkret() and the first process's kernel
stack, respectively.

forkret() (sheet 18) is the ordinary return path for the child after a
fork(); it loads the CPU registers from the process's trapframe
(p->tf), reduces the privilege level to that of user code, and starts
executing at the saved user EIP in the user code segment.  In this
case the contents of the trapframe are not copies of the registers
saved when the parent called fork(), but values created by userinit().
In particular, the EIP in the trapframe is zero.

forkret() calls forkret1() (sheet 24). forkret1() sets the stack
pointer to its argument, which is p->tf, and jumps to trapret. trapret
is the ordinary return path from system calls and interrupts.  It pops
much of the trapframe contents from the stack into registers.  The
final IRET pops the EIP, code segment selector, EFLAGS, ESP, and stack
segment selector.  The fact that the code segment selector has low
bits (CPL) equal to 3 causes the CPU to execute with no privilege.

Now the CPU is executing user instructions, with an EIP of zero, in a
segment whose base refers to the first instruction on sheet 67.
